# 使用 runas 约束流氓软件

## 前言

在之前的 [使用虚拟机约束流氓软件](https://zhuanlan.zhihu.com/p/479055960) 中，我们讨论了保持原生体验的前提下，彻底隔离流氓软件的方法：虚拟机+RemoteApp。

但，如果觉得虚拟机太重了，以及沙盒体验太割裂，HIPS逐应用配置太麻烦了呢？或者使用的不是专业版/Server版Windows，无法使用 Hyper-V 呢？假如我们只是单纯想要避免流氓软件扫盘，那么有没有更轻量的方法呢？

此处，我想到了除容器隔离（包括虚拟机、docker、sandboxie、WSL等）之外，来自操作系统DNA最深处，最基础的必备功能——用户账户隔离。

众所周知，Windows 使用的 [ACL访问控制列表](https://en.wikipedia.org/wiki/Access-control_list)，可以以大到分区小到文件的粒度，控制每个用户组/用户的精确权限。那么，我们只需要让流氓软件以另一个用户组的身份启动，就可以用ACL自动阻止它访问我们的文件，并且可以将访问权限一劳永逸地设置到用户/分区/目录本身，而不需要像sandboxes和HIPS（如火绒/组策略）那样每个应用单独设置一堆规则。

所以问题就简化到了，我们需要一个类似 Linux 的`sudo -u user app...`的工具，以及允许在当前用户会话中，以其他用户权限运行GUI应用的机制。

Windows 上有吗？巧了，还真有，早在NT内核第一次实装到消费级的 Windows 2000，就已经引入了 [runas](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc771525(v=ws.11)) 工具了，这里复制一下中文版本的帮助信息：

```text
C:\>runas /?
RUNAS 用法:

RUNAS [ [/noprofile | /profile] [/env] [/savecred | /netonly] ]
        /user:<UserName> program

RUNAS [ [/noprofile | /profile] [/env] [/savecred] ]
        /smartcard [/user:<UserName>] program

RUNAS [ [/machine:<MachineType>] ] /trustlevel:<TrustLevel> program

   /noprofile        指定不应该加载用户的配置文件。
                     这会加速应用程序加载，但
                     可能会造成一些应用程序运行不正常。
   /profile          指定应该加载用户的配置文件。
                     这是默认值。
   /env              要使用当前环境，而不是用户的环境。
   /netonly          只在指定的凭据限于远程访问的情况下才使用。
   /savecred         用用户以前保存的凭据。
   /smartcard        如果凭据是智能卡提供的，则使用这个选项。
   /user             <UserName> 应使用 USER@DOMAIN 或 DOMAIN\USER 形式
   /showtrustlevels  显示可以用作 /trustlevel 的参数的
                     信任级别。
   /trustlevel       <Level> 应该是在 /showtrustlevels 中枚举
                     的一个级别。
   /machine          指定进程的计算机架构。
                     <MachineType> 应为 x86|amd64|arm|arm64 之一。
   program           EXE 的命令行。请参阅下面的例子

示例:
> runas /noprofile /user:mymachine\administrator cmd
> runas /profile /env /user:mydomain\admin "mmc %windir%\system32\dsa.msc"
> runas /env /user:user@domain.microsoft.com "notepad \"my file.txt\""

注意:  只在得到提示时才输入用户的密码。
注意:  /profile 跟 /netonly 不兼容。
注意:  /savecred 跟 /smartcard 不兼容。
```

可以看到，`runas`提供了几乎等价于`sudo`的功能。并且在用户认证上，相比`sudo`每次都需要输入密码，否则需要用环境变量或者 askpass 应用转发密码，`runas`提供了`/savecred`选项用于保存凭据，一劳永逸地免去了输入密码的烦恼。

**注意**：`runas`方式启动隔离账户的应用，只能阻止对用户目录的扫盘，无法阻止后台录屏/监控剪贴板/监控键盘等操作。此类操作需要通过更进一步的方式防范，如HIPS和虚拟机。

**警告**：`/savecred`意味着目标用户对当前用户再也不设防了，任何人和任何应用程序，都能在当前用户环境下以`runas`唤起目标用户的程序。因此安全起见，仅推荐以管理员用户执行`runas /savecred`，而非反向使用，否则会让目标用户获得反向入侵的可能。

## 使用说明

### 准备环境

- 开启系统UAC（没UAC的系统和裸奔无异，根本没有隔离的必要）；
- 新建一个普通用户（此处假设叫作`App`），用于隔离运行程序：
  - 系统设置——账户——其他用户——添加账户（或者用`win+r`打开`control`，从控制面板中添加新用户）；
  - 当询问登录Windows账户时，选择 我没有/我不知道用户的Windows账户，然后建立为本地账户。
- 切换登录`App`账号，配置输入法和系统颜色（因为隔离应用是使用App账户的输入法设置和系统配色）；
- 关闭`App`账号中不需要的各类自启动（Win10/Win11 可通过任务管理器的启动页面开关），避免全局安装的软件自动生成了不必要的启动项；
  - 学有余力的，可以检查下服务设置，避免流氓软件注册的全局服务自启动。
- 执行一次`runas /user:App /savecred C:\Windows\System32\notepad.exe`，输入密码，等待记事本打开，用于验证`runas`可用性，以及提前保存凭据，避免后续还需要再次登录。
- 推荐给`App`用户设置一个复杂的强密码（反正我们用`/savecred`自动认证，不需用再次输入）。

### 调整权限

默认情况下，每个用户的用户目录（`C:\users\账号名`）都只有自己有访问权限，其他用户无权访问。因此，默认的用户账户隔离，已经解决的绝大部分流氓软件扫盘问题——因为浏览记录、文档、桌面、OneDrive等路径默认已经处于用户目录下面。

除此之外的路径，抛开特殊的系统路径外，其他大部分都是所有用户可见（包括非系统盘分区）。如果要避免流氓软件访问，则需要修改这些路径的ACL权限，比如**国内用户经典的单磁盘多分区，把文档等数据放在单独分区，而非用户账户的文档目录内**。

具体操作方法是：

- 打开需要调整权限的分区/目录/文件属性；
- 切换到`安全`选项卡；
- 点击`高级`按钮，进入高级安全设置窗口；
- 点击`更改权限`按钮，启用权限编辑；
- 选中`Users(计算机名\Users)`，点击`删除`按钮删除用户组权限；
  - 若提示该权限继承自父对象，那么要么直接删除上级路径的对应权限，要么点击`禁用继承`按钮，并在弹窗中选择`将已继承的权限转换为此对象的显式权限`；
- 点击`确定`，等待权限设置完毕，然后再点击属性对话框的`确定`，完成设置。
  - 注意：尽量避免有运行中的应用正在访问该路径，否则有可能因为文件占用，导致某些文件权限更改失败。

对于有编码能力的用户，可以通过PowerShell封装以上操作，此处为基于ChatGPT辅助编写的范例脚本：

```powershell
# 注意：此代码只移除了子目录和文件的权限，没有修改目标目录本身，需要进行调整
# 设置目标路径和用户
$path = "C:\YourDirectoryPath"
$userToRemove = "DOMAIN\UserName"  # 用户名或组名

# 获取目录及其子目录和文件
Get-ChildItem -Path $path -Recurse -Force | ForEach-Object {
    # 获取当前项的 ACL
    $item = $_
    $acl = Get-Acl -Path $item.FullName

    # 获取与目标用户匹配的权限规则
    $rulesToRemove = $acl.Access | Where-Object { $_.IdentityReference -eq $userToRemove }

    # 如果存在匹配规则，则移除
    if ($rulesToRemove) {
        foreach ($rule in $rulesToRemove) {****
            # 创建新的规则用于移除
            $acl.RemoveAccessRuleSpecific($rule)
        }

        # 应用新的 ACL
        Set-Acl -Path $item.FullName -AclObject $acl
        Write-Output "Removed permissions for $userToRemove on $($item.FullName)"
    }
}
```

![ACL删除权限范例](runas-for-malware/del-acl.png)

### 共享路径

由于ACL控制，被隔离的软件无法访问`host`用户路径，则双方需要有其他公共目录用于交换文件。通常，非用户目录的其他路径均为公共目录，如非系统分区。

此处，我推荐使用系统下载路径来交换文件，并且让双方账号共享下载路径。此处介绍一种通过ACL+符号链接实现的方案，可复用于其他共享路径需求：

- 进入`App`账户的`cmd`控制台，可以通过登录`App`账户操作，也可以在`host`账户下通过`runas /user:App /savecred C:\Windows\System32\cmd.exe`打开`App`权限的控制台会话；
- 进入`App`用户目录，通常为`C:`，`cd users\App`；
- 删除已有的下载目录（假设未修改系统下载路径）：`rmdir /s /q Downloads`；
- 制作目录符号链接，指向`host`的下载目录`mklink /D Downloads host下载目录路径`;
- 回到`host`用户，修改下载目录的ACL权限，通过 安全——编辑——添加——输入`App`确定——勾选允许修改，为`App`用户添加访问下载目录的权限。
![ACL添加权限范例](runas-for-malware/add-acl.png)

**扩展案例**：例如小狼毫输入法，也可通过创建符号链接指向`AppData\Roaming\Rime`来复用`host`中的配置。

### 修改快捷方式

在自己使用的账户中（此处假设账户名是`host`），用 [Everything](https://www.voidtools.com/) 等工具全局搜索`xxx.lnk`快捷方式，找到所有快捷方式。若要把应用固定至任务栏/开始页面，则需要提前固定好，生成任务栏快捷方式后再进行修改。

- 打开快捷方式属性面板；
- 切换至`快捷方式`页面；
- 修改`目标`一栏为：`C:\Windows\System32\runas.exe /user:App /savecred "原本目标路径"`
- 点击`更改图标`按钮，忽略错误提示，点击`浏览`，选择程序exe文件（即原本的目标路径），点`确定`设置图标。

![修改快捷方式](runas-for-malware/link.png)

然后就可以在`host`用户，通过快捷方式隔离启动应用了。

### 警告

`runas`的用户账户隔离只是君子手段，能防流氓软件，但防不住病毒和系统驱动/服务。对于此类场景，只有基于虚拟机（以及Windows沙盒）的隔离方式是相对安全的。

## 进阶扩展

### 数据迁移

在迁移聊天记录等`host`原有的应用数据时：

- 首选应用自带的导入导出功能，在`host`账户应用导出，在`App`账户应用中导入；
- 若无导入导出功能，则需要用复制粘贴迁移，切忌直接移动数据目录：
  - 移动目录不会更改权限，会导致数据文件依然是`host`权限；
  - 应该在`host`端将数据目录复制到公共路径，然后在`App`端再将公共路径中的数据目录复制到用户路径；

### AppData 本地安装

出于更进一步的洁癖需求，我们可以考虑将全局安装（`Program Files`或者非系统分区）的流氓软件，改为安装到`App`账户的用户目录中，这样这个应用的文件在`host`系统中就完全不可见，眼不见心不烦。

通常，我们只需要切换登录到`App`账户中，执行安装程序，并且修改安装路径到`C:\users\App\AppData\Local`下面即可。若安装程序需要管理员权限，则会自动唤起UAC窗口要求账号`host`授权，通过密码/pin/WindowsHello授权后，即可继续安装。

此方式安装的软件，若并非通过UAC管理员权限安装，则只会在`App`账户中生成快捷方式，我们需要手动在`host`账户制作快捷方式：

- 在`App`账户中：
  - 将应用exe的图标导出（可使用 [IconViewer软件](https://www.botproductions.com/iconview/iconview.html)，直接从exe属性面板中增加的`Icons`面板导出图标），保存到公共路径中；
  - 复制开始菜单路径`C:\Users\App\AppData\Roaming\Microsoft\Windows\Start Menu\Programs`下的快捷方式/目录到公共目录；
- 切换回`host`账户：
  - 全局搜索该应用快捷方式，删除安装在`C:\users\public`和`C:\ProgramData\Microsoft\Windows\Start Menu\Programs`下的全局公共快捷方式；
  - 将公共目录下的快捷方式复制到`C:\Users\host\AppData\Roaming\Microsoft\Windows\Start Menu\Programs`；
  - 将公共路径中保存的图标文件，迁移到持久保存的目录下，再把快捷方式属性中的图标修改为该图标文件。

**注意**：使用UAC安装的应用，可能会把用户路径识别为`host`路径，除了安装路径外，还需要检查软件数据路径的配置。

### uri唤起

经过上述方式通过`App`账户隔离运行的应用，常规的聊天输入、复制粘贴、文件访问都没问题，但是通过uri关联唤起其他应用（典型为网址唤起浏览器）时，会启动`App`账户内的浏览器，不便于复用`host`中的浏览器会话。而如果直接在`App`账户的浏览器中操作，则会留下浏览记录和登录凭据，而被流氓软件扫盘。

此外，在主机端同样存在uri唤醒流氓软件的需求，例如百度网盘，此时也需要通过类似修改快捷方式的方法，让它改为唤醒`App`账户的流氓软件。

因此，我们需要调整系统中uri关联唤起的配置，即将响应唤起的账户中的uri配置，导入到发起uri唤起请求的账户中，并改写为`runas`方式。具体步骤为：

- 在响应uri唤起操作的账户中（如通过`App`中的聊天软件里的链接唤起`host`的浏览器，则此处为`host`账户）：
  - 启动注册表编辑器，寻找`HKEY_CURRENT_USER\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\uri名称`的配置项：
    - 若未找到，则需要到`HKEY_LOCAL_MACHINE`的相同路径下寻找；
    - 将该配置项右键导出到`UrlAssociations.reg`文件，保存到公共路径中；
    - 用记事本打开`UrlAssociations.reg`文件，修改其中的根目录至`HKEY_CURRENT_USER`，即将配置项从全局配置改为用户配置；
    - 查看`UrlAssociations\uri名称`配置项中的`UserChoice\ProgID`值（如 FireFox Nightly 浏览器是`FirefoxURL-6F193CCC56814779`）；
  - 寻找`HKEY_CURRENT_USER\Software\Classes\ProgID值`；
    - 若未找到，则需要寻找`HKEY_LOCAL_MACHINE\Software\Classes\ProgID值`；
    - 将该配置项右键导出到`ProgID.reg`文件，保存到公共路径中；
    - 用记事本打开`ProgID.reg`文件，修改其中的根目录至`HKEY_CURRENT_USER`，即将配置项从全局配置改为用户配置；
- 在发起uri唤起操作的账户中（如通过`App`中的聊天软件里的链接唤起`host`的浏览器，则此处为`App`账户）：
  - 修改系统设置中的默认启动应用，更改为与响应账户中同样的关联；
  - 双击导入修改后的`UrlAssociations.reg`和`ProgID.reg`文件；
  - 选择一个永久存储的路径，建立`"xxx.bat"`，保存唤起该uri的脚本，内容为：`C:\Windows\System32\runas.exe /user:目标账号 /savecred "HKEY_CURRENT_USER\Software\Classes\ProgID值\shell\open\command值"`；
  - 其中，原指令值中的双引号需要进行转义，在`bat`中使用`\`转义，即将`"`替换为`\"`。
  - 例如，对于FireFox Nightly，原指令为：`"C:\Program Files\Firefox Nightly\firefox.exe" -osint -url "%1"`；
  - 则bat中的指令应为`C:\Windows\System32\runas.exe /user:目标账户 /savecred "\"C:\Program Files\Firefox Nightly\firefox.exe\" -osint -url \"%1\""`（如通过`App`中的聊天软件里的链接唤起`host`的浏览器，则目标账户应为`host`账户）；
  - 将`HKEY_CURRENT_USER\Software\Classes\ProgID值\shell\open\command值`改为执行`"xxx.bat" "%1"`

此处不直接在`shell\open\command`中填写`runas`的原因是，指令中存在嵌套双引号，需要进行转义。而注册表的字符串转义存在歧义，使用bat格式转义、powershell格式转义和不转义，在特殊场景下都可能出现问题，因此改为调用bat脚本，在脚本内进行bat格式转义。

**坏消息**：若在`App`账户内通过此方式配置uri唤起浏览器的话，会将`host`账户凭据保存到`App`账户。此时若`App`账户中使用`runas`或类似方式，就可以越狱到`host`环境中执行操作。即`/savecred`仅防君子不防小人。

**好消息**：目前并未观测到常见的流氓软件有越狱动作，包括此方式越狱，和虚拟机一文中提到的sandboxie逃逸、容器逃逸、虚拟机逃逸。毕竟流氓软件只是伪君子，而非破坏者。

### 百度网盘

在上文本地安装的方式中，有一个例外是百度网盘——它必须 *以管理员账号身份，安装在管理员账号的普通权限可操作的路径下面，如管理员账号的`AppData`*。此处不得不用一些trick，来 *make baidu happy*：

- 从控制面板中修改`App`账户权限，将账户改为管理员账户；
- 登录`App`账户，执行百度网盘安装程序；
- 将安装路径修改至`C:\users\App\AppData\Local`下面；
- 切换回`host`账号，进入控制面板，将`App`账户改回普通账户。

这样安装的百度网盘，实测可以通过`runas`，以`App`账号权限正常启动运行。

然后参照 [uri唤起](#uri唤起) 一节，将host端的网页下载唤起百度网盘重定向至App端：

- 在`App`端：
  - 将`HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Baiduyunguanjia`注册表项导出；
  - 修改`.reg`文件中的根路径为`HKEY_CURRENT_USER`；
- 在`host`端：
  - 导入`reg`文件；
  - 修改导入后的`HKEY_CURRENT_USER\SOFTWARE\Classes\Baiduyunguanjia\shell\open\command`指令：
    - 将原有指令迁移至bat脚本中，改写为`runas`调用，如`C:\Windows\System32\runas.exe /user:App /savecred "\"C:\Users\App\AppData\Roaming\baidu\BaiduNetdisk\YunDetectService.exe\" "\"%1\""`
    - 将`shell\open\command`内容改为调用bat脚本，如`"C:\Users\host\Documents\Apps\BaiduNetDisk\BaiduNetDisk.bat" "%1"`；

此外，还可以再额外进行一些裁剪操作，屏蔽掉百度网盘中的一些模块：

- 进入百度网盘安装目录；
- 将`ShellFolder*.dll`/`YunOffice*.dll`/`YunShell*.dll`删除或移走备份；
- 将`sysres`目录下`YunShellCommand*.dll`删除或移走备份；
- 建立与上述文件同名的文件夹占位，避免因为更新等原因再次生成，**注意名称需要包含扩展名**；
- 将`module`目录下的`AiEngine`目录删除或移走备份；
- 在相同位置新建文本文件，重命名为`AiEngine`占位，避免再次生成，**注意需要删除.txt扩展名**；
- 修改上述占位文件/文件夹的属性，配置为只读属性，并修改安全权限，将所有者改为`SYSTEM`，并移除`SYSTEM`外的所有权限（也可以改为`TrustedInstaller`）；

以上操作屏蔽掉了任务管理器扩展、Office扩展、AI引擎、语音阅读引擎，实测网盘基础功能运行无障碍。

某些软件的广告模块也可用相同方式屏蔽，此处仅提供参考方案，请读者自行处理。除占位文件外，也可以通过删除文件权限、组策略禁止等方式屏蔽这些模块，但除了组策略/HIPS比较靠谱外，修改文件权限的方式可能会被具有admin权限的流氓应用覆盖。
