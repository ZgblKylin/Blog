# 插件化开发

我以前提到过，上份工作做军工软件时，基于插件框架把一个业务线做到流水线化了，该业务线的项目，可以让c with class的初级开发做流水线分工，一个月交付一个项目。刚才群里有人问是怎么做到的，我详细解读了下。




技术含量主要在插件化框架，就这个 [KylinPluginFramework](https://github.com/ZgblKylin/KylinPluginFramework)。用OSGI也行，只是写起来没这个简单。

然后业务上TL要给力，提前设计好软件架构，把子功能拆分成一个个插件，每个插件的接口尽量做到不需要关心外部逻辑，只需要填自己的接口函数和数据收发，这样就可以丢给只会c with class的新人写了。




流水线出货那个项目，是做大规模数据处理的，数据处理、展示的逻辑固定，就逐步迭代更新到业务框架里。

那个业务线不同项目的差异主要是数据格式，一个数据文件里，按照协议规范往里面存上百类不同的数据，然后存多少类数据、每类数据自己的格式是可以自定义的，这些类数据打包起来的格式是遵循协议的。

然后每类格式的解析、后续诊断处理的两套算法会变。

所以就把解析和诊断两步的算法抽离成算法插件，这样每次来一个新项目只需要对着协议文件写下新算法就行了。

后续逐渐加强了数据库配置和可视化编辑，可以可视化配置数据结构，这样从大的数据协议里抽取出每一类的数据就完全通用不需要额外代码了，只需要写每类数据的解析和诊断处理两个算法。
然后各类数据的存储方式虽然是自定义，但长期做下来也就那么七八种，通过算法初始化参数做自定义，然后把算法参数配置也在业务框架支持自动可视化，写了十条左右的通用解析算法，于是解析也直接可视化配置数据库就ok了。

后面诊断也差不多，80%的诊断需求都可以用通用算法拼接起来，于是也不用写代码了……

所以到后面完善后，来一个新项目，数据协议100%走配置，数据项解析80%走配置，解析后的数据诊断80%走配置，表格查看数据、数据曲线绘制、表格导出、曲线导出、诊断报表生成，这些都由业务框架自动集成好了，0工作量。

走配置那些就简单多了，开发测试都可以做。



技术方面含量不高，就是靠一个插件框架搭积木，然后很吃TL的设计和架构能力。因为相同业务线的多个项目，都是大同小异的，所以如何把“大同”部分剥离出来并保持扩展性，如何让“小异”部分可以合并为一些通用算法的拼接，通过配置来特化，这些才是需要深挖的。




我们那个数据处理框架，我离职前的版本里，已经可以配算法图了。每一类数据的解析算法/诊断算法，可以拿任意多个算法插件以数据流图的形式连接起来，这个图里甚至允许由回路，只需要有唯一一个输入和唯一一个数据就行。

然后每个算法的自定义参数，可以可视化配置，类似qt designer里配置控件属性那样，不同数据类型的参数是不同的输入方式。而且支持任意层级的容器参数嵌套，容器参数点开就是弹窗里配置一张新的参数表。

算法图是用graphicsview做的，类似visio画流程图那样直接拖就行。




军工外包的天花板都太低了，只能研究螺蛳壳里做道场，深挖下去后依旧可以不停的压缩成本提高效率。

数据处理那个业务线，跑的数据是1-6GB的二进制文件，里面每一条数据最多占8字节，最少占1字节，最后解析完后平均有100路，每路千万条的数据……然后客户要求在笔记本上看，数据表格可以任意滚动或者翻页看所有数据，最可怕的是曲线图要可以缩放到最小，把一个条目所有数据画到一个曲线里……

所以业务框架的架构倒是不难，那些可视化配置什么的都是堆工作量就行。烧脑的就是怎么在笔记本上处理和展示十亿级的数据，对了，踏马的还是32位系统……




# FAQ

**Q：**

KPPF跟CTK有啥区别？

**A：**

CTK很庞大，是按照整个OSGI标准写的。好处就是功能强大而且健壮，设计层面有全球软件工程几十年经验的支撑——毕竟OSGI可是设计模式玩的走火入魔的java的插件框架规范。

CTK的缺点就是重。哪怕支持Qt，开发效率上，比起直接写Qt依然要慢很多，发布/订阅一个事件，依然比Qt写一个信号槽繁琐太多。因为它是严格按照OSGI设计的，而OSGI是按照设计模式时代的古典Java的语言特性设计的，就很繁琐。

实际开发中，如果要modern c++风格，那么应该基于模板来设计，学习门槛会比较高，但编码效率、执行效率、抽象能力三者还镇可以兼顾，典型代表是purecpp社区老大写的rest-rpc(RPC框架)和cinatra(目前全球最快的http框架）。还有把libuv封装成modern c++的uvw。可以去GitHub看下它们的接口设计，非常漂亮。

要像Qt那样无脑的话，就是我们当时自己封装的kpf，深度整合Qt，基于Qt的事件系统来设计的发布订阅机制，代码编写比信号槽还简单……

OSGI太大了，接口设计对于modern c++也太笨重了，我觉得只适合写大规模系统级的大项目，比如EDA软件（芯片设计）、各类仿真软件这种，有灵活组装扩展需求的巨无霸项目。

小项目的话，拿Qt plugin简单封装下初始化配置、事件链接配置、加载搭积木配置，就可以写的很爽了，kpf其实就是这么做的。




**Q：**

主程序和插件之间，主程序调用插件的接口，怎么设计才尽可能兼容多个插件的接口呢？

**A：**
基于事件而不是基于接口。基于接口的话，一个类包含了一大堆接口，改一个就得联动改所有继承者。如果把接口类拆分开用多继承，那么会越拆越多。

基于事件的话，就只需要针对每一个单独的事件发布/订阅，无论对方怎么写的，遵循数据格式约定即可，就很像modern c++的concept。

基于事件的这个优点，其实在通用语言里很接近于DDD，数据驱动开发的思路。

不过基于事件的话是异步的，对于同步写起来更简单的，比如有返回值的双向工作，要么就带上个编号来区分返回值，也就是web开发的session思想。要么就用协程改进事件框架，这样可以用同步风格的代码写异步。要么就退化到接口了。

我们当时的指导思想就是这样，能走事件的全部走事件，只有迫不得已的时候才走接口继承。




# P.S.

文中涉及到的几个框架

- CTK: [GitHub](https://github.com/commontk/CTK) [官网](https://github.com/commontk/CTK)
- KPF: [Kylin Plugin Framework](https://github.com/ZgblKylin/KylinPluginFramework)
- Rest-RPC: [GitHub](https://github.com/qicosmos/rest_rpc)
- Cinatra: [GitHub](https://github.com/qicosmos/cinatra)

