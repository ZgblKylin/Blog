**Dominic Szablewski, [@phoboslab](http://twitter.com/phoboslab)**

—— 2021年11月24日，星期三

# [O(n)耗时的无损图像压缩](https://phoboslab.org/log/2021/11/qoi-fast-lossless-image-compression)

此处介绍QIO——*[还可以图像格式(Quite OK Image Format)](https://qoiformat.org/)*。它可以将RGB和RGBA图像无损压缩到类似PNG的尺寸，并且压缩速度快 **20-50倍**，解压速度快**3-4倍**。所有操作都是单线程，没有SIMD。而且它**简单到愚蠢**。

太长不看：300行C代码，单头文件，[github源码](https://github.com/phoboslab/qoi)，[此处为性能对比](https://phoboslab.org/files/qoibench/)。

![QOI压缩](lossless-image-compression-in-on-time/qoi-sample.png)

话说在前头，我并不知道我在做什么。我并不是专业研究压缩的，对赫夫曼编码和DCT一无所知。幸运的是，QOI对它们也一无所知。

我只是想了些我*认为*对压缩图片*可能有用*的方法，而结果让我大受震撼。

## 为什么？简单的吐槽。

文件格式。它们糟透了。我绝对讨厌那些老一套的东西。PNG、JPEG还有更烂的MPEG、MPV、MP4。它们的复杂度缝合得都快炸了，每一个细节都在尖叫着*“由财团设计”*。

不久前[我稍微研究了下MPEG](https://phoboslab.org/log/2019/06/pl-mpeg-single-file-library)。MPEG对视频压缩的出发点非常巧妙，特别是在1993年，但它的文件格式实在糟糕透顶。

我几乎能想象得到一群穿着各式西装得*动态图像**专家**组*，在开会讨论如何给一条视频流打上版权标识。于是，`copyright`标志位被写进了标准，并成功阻止了电影盗版的萌芽。

MPEG，是三十年前就颁布的工业标准，所有专利都早已过期，所有专业兴趣也被放弃了。然而，这份神圣的标准——名为*ISO/IEC 11172-2*——依然是被严格保守的秘密，只有那些花了足足200美元来资助神圣的ISO组织的人才能观看。

虽然也有开源的方案，但它们也同样相当复杂。它们从不与时俱进，需要庞大的库，大量的算力，而且难以使用。PNG的开源方案也全在折腾压缩率，同时伴随着复杂度的增长。

对于舍弃一定压缩率来换取速度和简约，这绝对有市场空间，但是没人去做。（好吧，[也许这群家伙在做](http://www.radgametools.com/)，但都是商用的。）

是的，[stb_image](https://github.com/nothings/stb)把我们从与libpng的折腾中拯救出来，而且在无数的游戏和应用中使用。而我之前专注于在[pl_mpeg](https://github.com/phoboslab/pl_mpeg)项目上对视频处理做同样的事，并且小有所成。

但是，如上所述，为什么没人回头去实现一个对标PNG的*简洁*的图片压缩方案，但不需要那么多折腾？为什么没人去实现一个类似MPEG的*简洁*的视频压缩方案，并且改用一种说人话的文件格式？

我本打算做后者：使用部分MPEG-1，并让它更好解析，更方便在GPU上加速。也就是一个*足够好*的视频编码。

不过我无意中做出了前者：在某些场景下能对标PNG的无损压缩格式，压缩率稍微差一点，但少了巨量复杂度。

## 技术细节

QOI通过简单的单轮处理来压缩/解压图像，每个像素只需要访问一次。

像素按以下方式（之一）编码：

- 前一个像素的重复；
- 指向之前见过的像素列表的索引；
- 与之前像素rgb的差值；
- 完整的rgb或rgba值。

结果值被打包为数据块，每块数据起始是2或8比特的`tag`（标识上述方式之一），后续是一系列数据位。所有数据块（`tag`和数据位）都按字节对齐，所以块与块之间不需要折腾各种移位。

这些不同的数据块类别是：

### 1. 前一个像素的重复

如果当前像素和前一个像素完全相同，那么行程长度+1。当某个像素和之前的像素不一致时，行程长度会被保存到编码数据中，而当前像素则会用其他三种方式处理。

```
┌─ QOI_OP_RUN ────────────┐
│         Byte[0]         │
│  7  6  5  4  3  2  1  0 │
│───────┼─────────────────│
│  1  1 │       run       │
└───────┴─────────────────┘
2-bit tag b11
6-bit 行程长度，重复之前的像素：1..62
```

### 2. 之前见过的像素的索引

编码器会维护一个持续更新的数组，记录之前遇到过的64个不同像素。如果发现当前像素仍在列表中，则会把数组索引保存到数据流中。

为了确保编码时的`O(n)` 效率，这张表只需要检索一次。检索用的位置标识通过rgba值的“hash”决定（其实就是`(r * 3 + g * 5 + b * 7 + a * 11)`）。线性搜索或者某些更复杂的记录方式可能会带来略微好一点的压缩率，但同样也会略微减慢速度。

```
┌─ QOI_OP_INDEX ──────────┐
│         Byte[0]         │
│  7  6  5  4  3  2  1  0 │
│───────┼─────────────────│
│  0  0 │     index       │
└───────┴─────────────────┘
2-bit tag b00
6-bit 颜色索引数组的下标：0..63
```

### 3. 与之前像素rgb的差值

如果目前像素和前一个像素差别很小，就把它们的差值保存到数据流。

这里有两种方案，根据差值的大小来选择。需要注意，该方法只关注RGB值，alpha值的变化代价更大。*（译者注：即该方法只用于alpha值相同的相邻像素）*

```
┌─ QOI_OP_DIFF ───────────┐
│         Byte[0]         │
│  7  6  5  4  3  2  1  0 │
│───────┼─────┼─────┼─────│
│  0  1 │  dr │  dg │  db │
└───────┴─────┴─────┴─────┘
2-bit tag b01
2-bit 红色通道与上一像素的差值 -2..1
2-bit 绿色通道与上一像素的差值 -2..1
2-bit 蓝色通道与上一像素的差值 -2..1


┌─ QOI_OP_LUMA ───────────┬─────────────────────────┐
│         Byte[0]         │         Byte[1]         │
│  7  6  5  4  3  2  1  0 │  7  6  5  4  3  2  1  0 │
│───────┼─────────────────┼─────────────┼───────────│
│  1  0 │   diff green    │   dr - dg   │  db - dg  │
└───────┴─────────────────┴─────────────┴───────────┘

2-bit tag b10
6-bit 绿色通道与上一像素的差值 -32..31
4-bit 红色通道差值减去绿色通道差值 -8..7
4-bit 蓝色通道差值减去绿色通道差值 -8..7
```

### 4. 完整的rgb或rgba值

如果之前的所有方式都不适用，就把完整的rgb或rgba值保存到数据流。

```
┌─ QOI_OP_RGB ────────────┬─────────┬─────────┬─────────┐
│         Byte[0]         │ Byte[1] │ Byte[2] │ Byte[3] │
│  7  6  5  4  3  2  1  0 │ 7 .. 0  │ 7 .. 0  │ 7 .. 0  │
│─────────────────────────┼─────────┼─────────┼─────────│
│  1  1  1  1  1  1  1  0 │   red   │  green  │  blue   │
└─────────────────────────┴─────────┴─────────┴─────────┘
8-bit tag b11111110
8-bit 红色通道值
8-bit 绿色通道值
8-bit 蓝色通道值

┌─ QOI_OP_RGBA ───────────┬─────────┬─────────┬─────────┬─────────┐
│         Byte[0]         │ Byte[1] │ Byte[2] │ Byte[3] │ Byte[4] │
│  7  6  5  4  3  2  1  0 │ 7 .. 0  │ 7 .. 0  │ 7 .. 0  │ 7 .. 0  │
│─────────────────────────┼─────────┼─────────┼─────────┼─────────│
│  1  1  1  1  1  1  1  1 │   red   │  green  │  blue   │  alpha  │
└─────────────────────────┴─────────┴─────────┴─────────┴─────────┘
8-bit tag b11111111
8-bit 红色通道值
8-bit 绿色通道值
8-bit 蓝色通道值
8-bit 透明通道值
```

就这些。

如果你有时间的话，可以看一看[qoi.h](https://github.com/phoboslab/qoi/blob/master/qoi.h)的源码。

## 向前看

认真地说，我是大受震撼。BMP和TIFF都有单次执行长度的编码，而GIF则是使用LZW压缩，但是没有处于二者之间的方案。为什么？我发现RLE和LZW之间的空间足够我花很多天研究，而且有更多可挖掘的内容。

编写QOI非常有趣。我用手头的图片样本做了个“测试器”。看到我的每个修改是如何影响压缩率的，感觉很爽。

通过进一步的工作，QOI可以作为无损视频编码的基础，用作投屏和类似场景。

QOI的SIMD加速也很酷，但是（就我从ARM上SIMD指令集的优先认知），这个格式可能不是很适合这么做。也许能有大佬来指下路？

我也对`简单`而无损的图片压缩格式中更多的探索空间激情满满。许多材质的压缩方案都有很棒的点子，但目前没有能和JPEG对标但是复杂度*更低*的。