# 信号槽的性能疑问

> `啷个利郎`提问：请教一个问题，Qt信号槽的性能如何，普通桌面级cpu最快能响应什么级别的信号，槽函数计算量很小的情况下，假设每1ms一个信号，能够每次及时进入槽函数吗？1us呢？目前做了5ms一个信号的实验，上万次响应是没有丢失信号的。

关于信号槽的性能问题，一直有很多人担心并提问。



在这里，我借用关于多线程的一个经典语录来类比一下。

> 如果你不确定互斥锁有没有性能问题，需不需要换成无锁并发的解决方案，说明互斥锁并没有成为你的性能瓶颈——等你的程序性能需求到这个级别了，你自然知道该不该用互斥锁。

信号槽同理。



信号槽的确慢，但这个慢是相对于函数调用而言，而不是相对于用户可感知的运行开销。在此之前，我们先要知道函数调用有多块，才知道信号槽的慢到底是怎么个慢。

不同cpu指令集下，函数调用的开销是不同的。而且还受到缓存影响，缓存未命中时的内存延时，函数调用造成指令缓存失效的取指延时，变量出栈入栈的耗时等，这些都是很难确认的。

但绝大多数情况下，只要你函数传递的参数不是太过丧心病狂，也没遇到太严重的缓存失效的话，那么一次函数调用的开销，可以认为是大约两位数的时钟周期。

现代CPU主屏都是GHz级别，两位数的时钟周期，换算成时间也就是个位数纳秒。



这个时间是大还是小呢？

如果你函数里面仅仅只有一个`i++`，那么就一个时钟周期，远小于函数调用开销。

但现代编译器都有优化，过小的函数调用会被自动内联，不会出现调用开销。

所以实际上，我们可以粗略地认为，函数执行开销远远大于调用开销，这个远远大于不仅仅是一个数量级那么简单。



而信号槽有多慢呢？

信号槽的**慢**，是相对于**函数调用**，而不是**函数执行**。

而且信号槽的编写目的一般是用于异步事件处理，本身的函数体内容就远远大于简单的做几个计算的普通函数，执行开销本身就很庞大。

相比之下，信号槽的开销，在你的开发能力和项目代码的技术深度真的摸到这个层次之前，完全是感知不到，并且可以忽略的。

当然，非要抬杠，写个`i++`做槽函数，一秒触发几百万次除外。



扩展阅读一下，Qt的信号槽究竟做了什么。

有兴趣的读者，可以查看自己任何一个有信号函数的工程，在编译生成的临时文件里找到`moc_xxx.cpp`，阅读一下moc自动生成的信号函数体。

该函数体内，会把所有函数参数取地址，转换成`void*`形式，连同该`MetaMethod`的编号以及`this`指针，传递至`QObject::qt_metacall`函数。

然后找到`qobject.cpp`源码，阅读`qt_metacall`函数即可。

`QObject::qt_metacall`函数内，会根据`MetaMethod id`和`this`指针，从发送对象的`QMetaObject`中找到对应的`QMetaMethod`，这基本就是一个get函数加一次字典检索。

然后基于`QMetaMethod`中记录的函数签名，对所有输入参数进行一次校验，这个不是常规的有效性校验之类，而是**san check**，有兴趣的可以搜一下**san check**在编程中的含义。这一步涉及到遍历`QMetaMethod`中的字典，然后做一次`O(n)`的检查操作。

在完成上述校验后，会根据`this`、`MetaMethod`两个维度，遍历所有对应的`Qt::Connection`信号槽连接（字典遍历），然后逐一触发。根据`connect`的连接类型差异，有两种触发方式。

  - 对于`DirectConnection`（及同线程`AutoConnection`）：从`Connection`中取到槽函数的`this`对象和`QMetaMethod`方法，然后将`void*`参数通过模板重新转换为对应的类型，执行目标方法。获取槽函数是直接从`Connection`中读取，无需查询。类型转换是模板函数，开销在编译期就完成。所以约等于一次回调（当然比回调开销还是要大一些，多了许多数据读取）。
  - 对于`QueuedConnection`（及跨线程`AutoConnection`）：
    - 本线程：根据`QMetaMethod`记录的函数签名，针对每个参数，分别构造对应类型的`QVariant`，并将输入参数拷贝构造到`QVariant`中，即N个`QVariant`的构造，以及N次内存拷贝。然后将这些`QVariant`和`Connection`信息，打包为`QMetaCallEvent`对象（一次对象构造），通过`qApp->postEvent`异步发送至对方线程（一次无锁队列的入队操作，不过我没看过Qt的eventloop源码，不知道是不是无锁队列）。
    - 目标线程：线程事件循环中，当该`QMetaCallEvent`到达队首时，将其出队（一次无锁队列出队操作），然后解包，解包时又会对所有参数进行一轮san check。完成解包和校验后，执行和前面一样的回调操作。



所以，对于`DirectConnection`，一次信号槽执行的开销 = m次变量读取(读取`QMetaObject`、`QMetaMethod`等等等) + 一次字典遍历 + 一轮sancheck(n个if) + 槽函数个数*函数指针回调。

字典遍历在多个槽函数时，平均下来可以忽略。在单个槽函数时，无需遍历只剩一个`if`也可以忽略。m次变量读取看人品，大概率可以被缓存，则对于每个缓存数据的读取，也是个位数指令周期级别。

所以`DirectConnection`相比于函数指针回调，额外开销大约是数十个时钟周期而已，这个开销甚至还比不上因为函数指针而不是直接调用从而造成的潜在的缓存失效代价——然而信号槽对标的本来就是函数指针回调，而不是直接调用。

对于`QueuedConnection`，则开销分别位于两个线程里。两个线程运行不是完全同步的，所以不可能用执行时间-发送时间来求差值，中间线程同步、队列运行的时间不能计算在内。实际的overhead = 直接调用开销 + 1轮sancheck(n个if) + 2次队列操作(两三个if和两三个指针读取/赋值) + 2次线程写同步(无锁/有锁不确定)。如果是无锁同步的话，那么可以认为overhead大约是`DirectConnection`的两倍，相比于`QueuedConnection`的特性带来的好处而言，完全是血赚。

当然，`QueuedConnection`还有个额外的不确定性，那就是在调度事件队列时，如果事件队列为则，则线程会阻塞等待，来新事件后被唤醒——那么会有一次线程休眠和唤醒的开销，这个开销是远远重于任何框架任何实现方式的单次事件开销。

所以多线程开发中，需要考虑的反而不是`QueuedConnection`的问题，而是线程同步原语的选择，线程运行的方式，线程挂起与唤醒的控制等等。



所以可以大约定性地得出一个结论——对于大多数场景而言，信号槽相比于函数指针回调的额外开销，不会超过数百个时钟周期——按照CPU频率换算一下，也就是不会超过1us。
1us大不大？分子分母颠倒一下，也就是每秒百万次。

且不说信号槽了，你的程序所有函数加起来，每秒能有百万次调用吗？





如果觉得Qt信号槽内部实现代码太复杂啃不动的话，可以去看我的[KylinPluginFramework](https://github.com/ZgblKylin/KylinPluginFramework)，作为一个学习项目还是很不错的。那里面我自己做了一套事件系统，比信号槽代码少、性能好、功能多——当然一是偷了懒，异步事件服用了Qt事件循环，二是少了许多校验，代码健壮性比不过Qt。

说真的，Qt信号槽部分的代码健壮性，可以说超过了绝大部分嵌入式项目，我甚至怀疑那代码可以直接往航天飞机上放——如果你懂我后半句话的代表什么的话